<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="구 블로그에서 가져옴"><title>원리부터 파악하는 OpneCV</title><link rel=canonical href=https://iwanhae.github.io/p/introduction-to-opencv/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="원리부터 파악하는 OpneCV"><meta property="og:description" content="구 블로그에서 가져옴"><meta property="og:url" content="https://iwanhae.github.io/p/introduction-to-opencv/"><meta property="og:site_name" content="iWan"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2015-10-03T00:00:00+00:00"><meta property="article:modified_time" content="2015-10-03T00:00:00+00:00"><meta property="og:image" content="https://iwanhae.github.io/p/introduction-to-opencv/OpenCV_Logo_with_text.png"><meta name=twitter:title content="원리부터 파악하는 OpneCV"><meta name=twitter:description content="구 블로그에서 가져옴"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://iwanhae.github.io/p/introduction-to-opencv/OpenCV_Logo_with_text.png"></head><body><div class="container flex on-phone--column align-items--flex-start extended article-page with-toolbar"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hub2a4b6b69d3b0618960cb9af6c0975e0_643282_300x300_resize_box_2.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>😎️</span></figure><h1 class=site-name><a href=https://iwanhae.github.io>iWan</a></h1><h2 class=site-description>#include "Hi.h"</h2></header><ol class=menu id=main-menu><li><a href=https://iwanhae.github.io/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=https://iwanhae.github.io/welcome-to-iwan><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=https://iwanhae.github.io/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li></ol></aside><main class="main full-width"><div id=article-toolbar><a href=https://iwanhae.github.io class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><article class="has-image main-article"><header class=article-header><div class=article-image><img srcset="/p/introduction-to-opencv/OpenCV_Logo_with_text_hu831880a48d7ecc3410cf3de8dbeec4b7_31958_1024x0_resize_box_2.png 1024w, /p/introduction-to-opencv/OpenCV_Logo_with_text_hu831880a48d7ecc3410cf3de8dbeec4b7_31958_2000x0_resize_box_2.png 2000w" src=/p/introduction-to-opencv/OpenCV_Logo_with_text_hu831880a48d7ecc3410cf3de8dbeec4b7_31958_2000x0_resize_box_2.png width=600 height=739 loading=lazy alt="Featured image of post 원리부터 파악하는 OpneCV"></div><div class=article-details><header class=article-category><a href=https://iwanhae.github.io/categories/computer-vision/ class=color-tag data-image=/p/introduction-to-opencv/OpenCV_Logo_with_text_hu831880a48d7ecc3410cf3de8dbeec4b7_31958_20x20_fill_box_smart1_2.png data-key=introduction-to-opencv data-hash="md5-WR28D7T2CUYb6q4JUcA2Kw==">Computer Vision</a>
<a href=https://iwanhae.github.io/categories/introduction/ class=color-tag data-image=/p/introduction-to-opencv/OpenCV_Logo_with_text_hu831880a48d7ecc3410cf3de8dbeec4b7_31958_20x20_fill_box_smart1_2.png data-key=introduction-to-opencv data-hash="md5-WR28D7T2CUYb6q4JUcA2Kw==">Introduction</a></header><h2 class=article-title><a href=https://iwanhae.github.io/p/introduction-to-opencv/>원리부터 파악하는 OpneCV</a></h2><h3 class=article-subtitle>구 블로그에서 가져옴</h3><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>2015년 10월 03일</time></footer></div></header><section class=article-content><h3 id=서론>서론</h3><p>OpenCV에 대해 포스팅되는 글들에대해 개인적으로 분류를 해보자면 크게 두가지 부류가 있다.
하나는 &ldquo;<strong>나도 이게 어떻게 되는지는 모르지만 일단 되는류</strong>&rdquo; 고 나머지 하나는 &ldquo;<strong>난 이미 너무 자세히 알고있어서 기초에대해 포스팅할 마음이 안생기는류</strong>&ldquo;이다.</p><p>이것이 진실로 그러하든 그러하지않던 초보자에게 한글로된 문서만 보고 OpenCV입문이란 힘든다는것은 아마 대부분의 사람들이 공감할것이라 믿는다.</p><p>그래서 비교적 최신버전(3.0)에 기초하여 OpenCV가 사용하는 기본적인 함수부터 개발자가 이러한 함수를 만든 의도까지 살려서 <strong>C++</strong> 혹은 <strong>객체지향언어의 본질</strong>을 깨달은 사람을 대상으로 <strong>&ldquo;이정도 이해했으면 나머지는 알아서 할수있겠지!"</strong> 정도까지 글을 적어보려고 한다.</p><p>이 글은 시간이 날때마다 업데이트되며 이 블로그에서 OpenCV에대한 튜토리얼은 이 글 하나로 끝낼 생각이다.</p><p>또한 어느정도 주관이 들어가고 본인도 완벽히 이해하지 못하는 내용에대해서는 추측으로 글을 쓸수도 있기에 틀린내용이 있으면 댓글로 남겨주길 바란다.</p><p>설치에 대한 글은 따로 적지 않겠다. 윈도우 환경이라면 개인적으로 <a class=link href=http://webnautes.tistory.com/673 target=_blank rel=noopener>이 글</a>을 추천한다.</p><h3 id=소개>소개</h3><p>OpenCV는 인텔의 후원을 받으며 다음과 같은 목표를 가지고 있다.</p><blockquote><p>Advance vision research by providing not only open but also optimized code for basic vision infrastructure. No more reinventing the wheel.</p></blockquote><blockquote><p>Disseminate vision knowledge by providing a common infrastructure that developers could build on, so that code would be more readily readable and transferable.</p></blockquote><blockquote><p>Advance vision-based commercial applications by making portable, performance-optimized code available for free—with a license that did not require to be open or free themselves.</p></blockquote><p>영어 울렁증인 분들을 위해 번역해 보자면</p><blockquote><p>오픈되있고 기초적인 영상처리에대한 최적화된 코드를 제공해 쓸데없는 시간낭비를 줄임으로서 진보된 영상처리 연구일것.</p></blockquote><blockquote><p>개발자들이 쓸수있고 일반화되서 다른 개발자들이 이해할수 있고 변형가능하게 함으로서 영상처리에관한 지식을 퍼뜨릴것.</p></blockquote><blockquote><p>대충 누구나 쓸수있고 코드를 꼭 공개하지 않아도 되게할것 (라이센스 관련 이야기 입니다.)</p></blockquote><p>이것이 OpenCV의 기본 모토이며 실제로 잘 지키고 있으며 OpenCV자체 소개글에 의하면 2500개가 넘는 영상처리 관련 알고리즘이 최적화되서 포함되 있다고 한다.</p><p>즉, 요약하자면 우리는 복잡한 영상처리 알고리즘들을 완벽히 구현해낼 필요없이 OpenCV에서 제공하는걸 가져다 쓰면 되고, 또 이것들은 세계에 존재하는 우리만큼 (혹은 우리보다) 똑똑한 사람들이 &ldquo;이것"에만 집중해서 만들어져 엄청난 최적화와 뛰어난 메모리관리가 가능한 라이브러리들의 집합체 라는것이다.</p><p>참고로 말하자면 상황에따라 개인이 집적 코딩하는게 더 효율적인 순간도 있겠지만 어지간해서는 알고리즘에대한 기초적인 이해만 가지고 OpenCV를 사용해 코딩하는게 생산성도 높고 결과물도 더 빠르다.</p><h3 id=mat--기초적인-이미지-저장소>Mat -기초적인 이미지 저장소</h3><ol><li><p>기초
OpenCV자체가 영상처리에 관해 다루는 라이브러리인 만큼 &ldquo;영상&rdquo;, 즉 &ldquo;이미지"에 대한 데이터가 저장될 장소가 일단 필요하다. OpenCV에서는 이 저장소를 <code>Mat</code>이라 한다. (Matrix의 앞글자만 따온것이다)<em>(실제 Mat은 이미지 저장소로도 쓰이지만 행렬식으로써의 사용도 가능하다. 추후언급)</em></p><pre><code> 구버전을 기준으로 OpenCV를 접하신 분들은 아마 `IplImage`의 존재를 아시는 분이 있을것이다. 둘다 이미지를 저장하고 관리하는건 같으나 다른점이 있다면 `IplImage`는 수동으로 메모리 배치와 해체를 해줌으로서 메모리 관리를 해줘야 한다면 `Mat`은 하나의 객체, 즉 `Class`로서 자체적으로 메모리관리가 가능하다는 것이다.
 물론 `IplImage`의 존재가 사라진것은 아니며 그대로 쓸수있긴 하지만 OpenCV 개발자쪽에서도 이건 권장하지 않으며 프로젝트가 방대해짐에따라 메모리관리의 지옥에 빠지기 싫다면 `Mat`을 사용하도록 하자.
</code></pre></li></ol><p><code>Mat</code>은 이미지를 저장하는 하나의 <code>class</code>이며 이것은 크게 <code>헤더</code>와 <code>데이터 포인터</code>로 구성되어 있다.</p><p><code>헤더</code>는 자기 자신에 저장되있는 이미지에 대한 정보를 담는 곳이다. 예를들면 &ldquo;이미지 크기&rdquo;, &ldquo;이미지 포맷"같은것들 말이다. 그리고 <code>데이터 포인터</code>는 <strong>이미지 하나하나의 픽셀</strong>이 담겨있는 <strong>메모리 주소</strong>에대한 정보를 가지고 있는 곳이다.</p><p>이 두가지 부류의 정보가 담겨있는 <code>Mat</code>은 다음과 같이 사용가능하다.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Mat</span> <span class=n>A</span><span class=p>,</span> <span class=n>C</span><span class=p>;</span>                          <span class=c1>// Mat클래스 A와 C를 선언
</span><span class=c1></span><span class=n>A</span> <span class=o>=</span> <span class=n>imread</span><span class=p>(</span><span class=s>&#34;a.jpg&#34;</span><span class=p>,</span> <span class=n>IMREAD_COLOR</span><span class=p>);</span> <span class=c1>// imread함수로 이미지&#34;a.jpg&#34;를 불러옴
</span><span class=c1></span><span class=n>Mat</span> <span class=nf>B</span><span class=p>(</span><span class=n>A</span><span class=p>);</span>                          <span class=c1>// B를 선언하고 A를 복사해옴
</span><span class=c1></span><span class=n>C</span> <span class=o>=</span> <span class=n>A</span><span class=p>;</span>                             <span class=c1>// C에 A를 대입함.
</span></code></pre></div><p>근데 여기서 한가지 주의해야할 점이 있다.
일단 <code>imread</code>함수를 통해 <code>A</code>에 &ldquo;헤더"와 &ldquo;데이터 포인터"가 저장된것은 좋으나 <code>B</code>가 A로부터 정보를 복사해갈때 이역시 &ldquo;헤더"와 &ldquo;데이터 포인터"만 복사가 되지 &ldquo;이미지 데이터"그 자체는 복사가 안된다. 이는 <code>C</code>역시도 마찬가지 인데 이 일로 인해 생길수 있는 현상은 **<code>C</code>의 이미지 데이터를 이진화 했는데 <code>A</code>의 데이터도 이진화 되버리고 <code>B</code>역시 같아졌다!**와 같은것을 초래할수 있다.</p><p>이를 방지하기 위해</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>C</span> <span class=o>=</span> <span class=n>A</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span>
<span class=n>C</span><span class=p>.</span><span class=n>copyTo</span><span class=p>(</span><span class=n>A</span><span class=p>);</span>
</code></pre></div><p>와 같은식으로 <strong>데이터를 통째로 복사</strong>해오면 <code>C</code>가 변한다 해서 <code>A</code>가 변하지 않고 그 반대도 마찬가지느 참고하도록 하자.</p><ol start=2><li>이미지 저장방법</li></ol><p><code>Mat</code>은 위에서 말했다싶이 <strong>Matrix</strong>에서 따온 글자임으로 그 저장방법도 행렬처럼 저장이 된다.
<img src=./b6df115410caafea291ceb011f19cc4a19ae6c2c.png alt></p><p>위 사진은 <code>BGR</code>*(RGB에서 순서만 바뀜)*형식의 이미지가 메모리상에 저장되는 방법이다. 보다싶이 한 픽셀에 **&ldquo;파랑&rdquo;,&ldquo;초록&rdquo;,빨강&rdquo;**이 순서대로 저장되 있다.</p><p>이건 메모리 주소상으로도 마찬가지이며 만약 어떤 포인터 <code>ptr</code>이 <strong>(x=12,y=15) 픽셀의 파란색</strong>을 가리키고 있다면 <code>ptr++</code>를 해주면 그 다음위치인 <strong>(x=12,y=15) 픽셀의 초록색</strong>을 가리키게 되는 구조이다.</p><p>OpenCV에서는 이런 **&ldquo;파랑&rdquo;,&ldquo;초록&rdquo;,빨강&rdquo;**같은걸 <strong>채널</strong>이라 부른다. 이경우 채널수는 3개가 되며 이 형식은 이미지의 포맷별로 다르며 임의로 자신이 구성할수도 있다.</p><p>참고로 <code>OpenCV</code>가 지원하는 이미지 포맷은 크게 4가지 정도가 있다.</p><ol><li><p>RGB : 우리가 잘 알고있고 흔히 쓰는방법이다. 각 픽셀별로 <code>빨강</code>,<code>초록</code>,<code>파랑</code>을 0~255사이의 숫자로 색을 표현하는 것이다. 주의해야할 점은 OpenCV는 RGB대신 BGR(순서만 바꿈)형식으로 데이터를 저장하니 참고해 두자.</p></li><li><p><a class=link href=https://ko.wikipedia.org/wiki/HSV_%EC%83%89_%EA%B3%B5%EA%B0%84 target=_blank rel=noopener>HSV, HLS</a> : 둘다 같은것으로 색상<strong>Hue</strong>, 채도<strong>Saturation</strong>, 휘도(밝기)**Value(luminance)**로 색을 표현한다. 밝기에따라 색이 달라지는 RGB와 다르게 마지막 성질만 제외하면 비교적 일정한 데이터를 얻을수 있어서 영상처리분야에 애용되는 포맷이다.</p></li><li><p>YCrCb : jpg에서 일반적으로 쓰이는 포맷이다.</p></li><li><p>CIE L<em>a</em>b* : <a class=link href=https://ko.wikipedia.org/wiki/Lab_%EC%83%89_%EA%B3%B5%EA%B0%84 target=_blank rel=noopener>위키피디아</a></p></li><li><p>초기화
<code>Mat</code>에 이미지를 넣지 않고도 그냥 초기화 하는법도 있다.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Mat</span> <span class=nf>M</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span> <span class=n>CV_8UC3</span><span class=p>,</span> <span class=n>Scalar</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>255</span><span class=p>));</span>
</code></pre></div></li></ol><p>순서대로 **&ldquo;행&rdquo;, &ldquo;열&rdquo;, &ldquo;초기화 타입&rdquo;, &ldquo;초기화 내용&rdquo;**으로 구성되며 초기화 타입의 경우 **CV_(하나의 데이터당 비트수)(Signed 인지 Unsigned 인지)C(채널수)**와 같은 형식을 가진다. 위 예제의경우 **데이터당 8비트의 저장공간을 가지고, Unsigned 형태로, 3가지 채널(RGB)를 가진다**라는 의미이다.</p><p>이걸</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;M = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>M</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</code></pre></div><p>이렇게 출력해주면</p><p><img src=./MatBasicContainerOut1.png alt></p><p>이런 형식의 데이터를 가지게 된다.</p><h3 id=실습>실습</h3><p>다음은 웹캠동영상을 불러와 화면에 띄우는 코드이다. 쉬어가는겸 한번 해보자.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cp>#include</span> <span class=cpf>&lt;opencv2/core/core.hpp&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;opencv2/highgui/highgui.hpp&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=k>using</span> <span class=k>namespace</span> <span class=n>cv</span><span class=p>;</span>
<span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>**</span> <span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
	<span class=n>VideoCapture</span> <span class=n>vc</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>//0번웹캠 초기화
</span><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>vc</span><span class=p>.</span><span class=n>isOpened</span><span class=p>())</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 연결실패
</span><span class=c1></span>
	<span class=n>Mat</span> <span class=n>img</span><span class=p>;</span> <span class=c1>//img선언
</span><span class=c1></span>	<span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
		<span class=n>vc</span> <span class=o>&gt;&gt;</span> <span class=n>img</span><span class=p>;</span> <span class=c1>//0번웹캠에서 받은 데이터를 img에 대입
</span><span class=c1></span>        <span class=c1>//데이터 자체를 복사하는지는 모름, 아시는분은 알려주세요.
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>img</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=k>break</span><span class=p>;</span> <span class=c1>//받은거 없으면 종료
</span><span class=c1></span>		<span class=n>imshow</span><span class=p>(</span><span class=s>&#34;cam&#34;</span><span class=p>,</span> <span class=n>img</span><span class=p>);</span>  <span class=c1>//화면에 띄우기
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>waitKey</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> <span class=o>==</span> <span class=mi>27</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span> <span class=c1>//ESC키 눌리면 종료
</span><span class=c1></span>	<span class=p>}</span>
	<span class=n>destroyAllWindows</span><span class=p>();</span>
	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h3 id=필터-적용해보기>필터 적용해보기</h3><p>앞으로 OpenCV로 영상처리를 하게되면 필터적용은 거의 필수적으로 하게될것이다. 지금은 OpenCV 공식 예제중 하나인 **&ldquo;Sharpen&rdquo;**에 대해 시도해 보자.</p><p>일단 **&ldquo;Sharpen&rdquo;**은 다음과 같은 공식을 적용하게된다.</p><p><img src=./7c2c71b792e6560be979d359e8f3f3b34c7938ff.png alt></p><p>수식 울렁증인 분들을 위해 간단한 해석을 해보자면 위의식은</p><pre><code>좌표평면에서 (i,j)의 픽셀에 대해 (각 화소별로) 자신의 5배에다가 사방에 있는 픽셀의 더한값을 뺀다.
</code></pre><p>를 의미한다. (아래 그림에서 좌표가 표시된것만 연산에 참여한다고 보면 된다.)</p><p><img src=./mat.png alt=matrix></p><p>그리고 밑의식은 그걸 위 그림과 같은 배치로 행렬로 나타낸 것이다.</p><p><strong>i,j</strong>인 자신을 5배 한뒤 그 주변의 것들을 <strong>-1</strong>배해서 더해주는 것이다. (한마디로 위, 아래 두식모두 같은 의미를 가진다.)</p><p>이를 우리는 <strong>Kernel</strong> <em>(핵심, 알맹이)</em> 라고 부른다.</p><p>이 식을 <strong>두가지</strong>방법으로 적용시켜 보겠다.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=cp>#include</span> <span class=cpf>&lt;opencv2/core/core.hpp&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;opencv2/highgui/highgui.hpp&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;opencv2/imgproc/imgproc.hpp&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=k>using</span> <span class=k>namespace</span> <span class=n>cv</span><span class=p>;</span>
<span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>Sharpen</span><span class=p>(</span><span class=k>const</span> <span class=n>Mat</span><span class=o>&amp;</span> <span class=n>myImage</span><span class=p>,</span> <span class=n>Mat</span><span class=o>&amp;</span> <span class=n>Result</span><span class=p>)</span>
<span class=p>{</span>
	<span class=n>CV_Assert</span><span class=p>(</span><span class=n>myImage</span><span class=p>.</span><span class=n>depth</span><span class=p>()</span> <span class=o>==</span> <span class=n>CV_8U</span><span class=p>);</span>

	<span class=n>Result</span><span class=p>.</span><span class=n>create</span><span class=p>(</span><span class=n>myImage</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=n>myImage</span><span class=p>.</span><span class=n>type</span><span class=p>());</span>
	<span class=k>const</span> <span class=kt>int</span> <span class=n>nChannels</span> <span class=o>=</span> <span class=n>myImage</span><span class=p>.</span><span class=n>channels</span><span class=p>();</span>

	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>myImage</span><span class=p>.</span><span class=n>rows</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
	<span class=p>{</span>
    	<span class=k>const</span> <span class=n>uchar</span><span class=o>*</span> <span class=n>previous</span> <span class=o>=</span> <span class=n>myImage</span><span class=p>.</span><span class=n>ptr</span><span class=o>&lt;</span><span class=n>uchar</span><span class=o>&gt;</span><span class=p>(</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
    	<span class=k>const</span> <span class=n>uchar</span><span class=o>*</span> <span class=n>current</span> <span class=o>=</span> <span class=n>myImage</span><span class=p>.</span><span class=n>ptr</span><span class=o>&lt;</span><span class=n>uchar</span><span class=o>&gt;</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
    	<span class=k>const</span> <span class=n>uchar</span><span class=o>*</span> <span class=n>next</span> <span class=o>=</span> <span class=n>myImage</span><span class=p>.</span><span class=n>ptr</span><span class=o>&lt;</span><span class=n>uchar</span><span class=o>&gt;</span><span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>

    	<span class=n>uchar</span><span class=o>*</span> <span class=n>output</span> <span class=o>=</span> <span class=n>Result</span><span class=p>.</span><span class=n>ptr</span><span class=o>&lt;</span><span class=n>uchar</span><span class=o>&gt;</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>

    	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>nChannels</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nChannels</span> <span class=o>*</span> <span class=p>(</span><span class=n>myImage</span><span class=p>.</span><span class=n>cols</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
    	<span class=p>{</span>
    		<span class=o>*</span><span class=n>output</span><span class=o>++</span> <span class=o>=</span> <span class=n>saturate_cast</span><span class=o>&lt;</span><span class=n>uchar</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=n>current</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
			<span class=o>-</span> <span class=n>current</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>nChannels</span><span class=p>]</span> <span class=o>-</span> <span class=n>current</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=n>nChannels</span><span class=p>]</span> <span class=o>-</span> <span class=n>previous</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>next</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
	    <span class=p>}</span>
    <span class=p>}</span>

	<span class=n>Result</span><span class=p>.</span><span class=n>row</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>setTo</span><span class=p>(</span><span class=n>Scalar</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
	<span class=n>Result</span><span class=p>.</span><span class=n>row</span><span class=p>(</span><span class=n>Result</span><span class=p>.</span><span class=n>rows</span> <span class=o>-</span> <span class=mi>1</span><span class=p>).</span><span class=n>setTo</span><span class=p>(</span><span class=n>Scalar</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
	<span class=n>Result</span><span class=p>.</span><span class=n>col</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>setTo</span><span class=p>(</span><span class=n>Scalar</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
	<span class=n>Result</span><span class=p>.</span><span class=n>col</span><span class=p>(</span><span class=n>Result</span><span class=p>.</span><span class=n>cols</span> <span class=o>-</span> <span class=mi>1</span><span class=p>).</span><span class=n>setTo</span><span class=p>(</span><span class=n>Scalar</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
<span class=p>}</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>**</span> <span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
	<span class=n>VideoCapture</span> <span class=n>vc</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>

	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>vc</span><span class=p>.</span><span class=n>isOpened</span><span class=p>())</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 연결실패
</span><span class=c1></span>
	<span class=n>Mat</span> <span class=n>img</span><span class=p>;</span>
	<span class=n>Mat</span> <span class=n>output</span><span class=p>;</span>
	<span class=n>Mat</span> <span class=n>kern</span> <span class=o>=</span> <span class=p>(</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>
	<span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
	<span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>

	<span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
		<span class=n>vc</span> <span class=o>&gt;&gt;</span> <span class=n>img</span><span class=p>;</span>

    	<span class=k>if</span> <span class=p>(</span><span class=n>img</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=k>break</span><span class=p>;</span>
    	<span class=n>imshow</span><span class=p>(</span><span class=s>&#34;cam&#34;</span><span class=p>,</span> <span class=n>img</span><span class=p>);</span>
    	<span class=k>if</span> <span class=p>(</span><span class=n>waitKey</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> <span class=o>==</span> <span class=mi>27</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span> <span class=c1>//ESC
</span><span class=c1></span>
    	<span class=n>Sharpen</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>output</span><span class=p>);</span>       <span class=c1>//위쪽의 식을 적용시킨 코드
</span><span class=c1></span>    	<span class=n>imshow</span><span class=p>(</span><span class=s>&#34;output&#34;</span><span class=p>,</span> <span class=n>output</span><span class=p>);</span>
	
    	<span class=n>filter2D</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>output</span><span class=p>,</span> <span class=n>img</span><span class=p>.</span><span class=n>depth</span><span class=p>(),</span> <span class=n>kern</span><span class=p>);</span> <span class=c1>//아래쪽 식을 적용시킨 코드
</span><span class=c1></span>		<span class=n>imshow</span><span class=p>(</span><span class=s>&#34;output2&#34;</span><span class=p>,</span> <span class=n>output</span><span class=p>);</span>
	<span class=p>}</span>
    <span class=n>destroyAllWindows</span><span class=p>();</span>
	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>일단 위쪽식을 적용한 **Sharpen()**함수에 대해 설명해 보겠다.</p><ol><li><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>CV_Assert</span><span class=p>(</span><span class=n>myImage</span><span class=p>.</span><span class=n>depth</span><span class=p>()</span> <span class=o>==</span> <span class=n>CV_8U</span><span class=p>);</span>
</code></pre></div></li><li><p>이 함수는 <code>myImage</code>가 CV_8U, 즉 8비트의 Unsigned 형태인지를 보고, 아니라면 <code>ERROR</code>를 <code>Throw</code>한다. 한마디로 계산할려는 <code>Mat</code>이 제대로 됬는지를 확인하는 함수이다.<code>Resaut</code>를 <code>myImage</code>와 같은 크기와 저장방식을 가지게 초기화 해주고, <code>nChannels</code>에는 채널의 수가 들어간다. 이경우 <code>BGR</code>형태의 이미지이기 때문에 <code>nChannels</code>에는 <code>3</code>이 입력된다.</p></li><li><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>myImage</span><span class=p>.</span><span class=n>rows</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
</code></pre></div><p>1행부터 마지막행까지 반복</p></li><li><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>const</span> <span class=n>uchar</span><span class=o>*</span> <span class=n>previous</span> <span class=o>=</span> <span class=n>myImage</span><span class=p>.</span><span class=n>ptr</span><span class=o>&lt;</span><span class=n>uchar</span><span class=o>&gt;</span><span class=p>(</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
<span class=k>const</span> <span class=n>uchar</span><span class=o>*</span> <span class=n>current</span> <span class=o>=</span> <span class=n>myImage</span><span class=p>.</span><span class=n>ptr</span><span class=o>&lt;</span><span class=n>uchar</span><span class=o>&gt;</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
<span class=k>const</span> <span class=n>uchar</span><span class=o>*</span> <span class=n>next</span> <span class=o>=</span> <span class=n>myImage</span><span class=p>.</span><span class=n>ptr</span><span class=o>&lt;</span><span class=n>uchar</span><span class=o>&gt;</span><span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
<span class=n>uchar</span><span class=o>*</span> <span class=n>output</span> <span class=o>=</span> <span class=n>Result</span><span class=p>.</span><span class=n>ptr</span><span class=o>&lt;</span><span class=n>uchar</span><span class=o>&gt;</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
</code></pre></div></li><li><p>매 반복이 시작될때마다</p></li><li><p>previous 는 자신의 윗(이전)행</p></li><li><p>current 는 자신의 행</p></li><li><p>previous 는 자신의 아랫(다음)행</p></li></ol><pre><code>을 배열로 불러오고
</code></pre><p>출력 <code>Mat</code>에서 자신의 행의 첫번째 픽셀의 첫번째 채널을 (<code>*output</code>) <strong>Unsigned char</strong> 형태로 가르킨다.</p><ol start=6><li><p><code>output</code>이 가르키는 메모리 공간에 <code>5 * current[i] - current[i - nChannels] - current[i + nChannels] - previous[i] - next[i])</code>을 대입한다.</p><p>이때 위 <code>Mat</code>에서 메모리공간에 이미지가 저장되는 방법을 소개했을때 보여준것처럼 자신의 바로 다음공간에는 다른 채널의 데이터가 들어가 있으므로 <strong>i - nChannels</strong>을 가르킴으로서 자신 채널의 다음 픽셀을 가르키게 하는것이다.</p></li><li><p><code>saturate_cast&lt;></code>는 일종의 보호장치로 만약 연산결과가 <code>uchar</code>가 표시가능한 <strong>0~255</strong>를 넘어갔을때 <strong>0</strong>과 <strong>255</strong>중 더 가까운 수를 리턴해주는 함수이다.</p></li><li><p>그 후 <code>output</code>은 자신 다음의 저장공간을 가리킨다.</p></li></ol><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Result</span><span class=p>.</span><span class=n>row</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>setTo</span><span class=p>(</span><span class=n>Scalar</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
<span class=n>Result</span><span class=p>.</span><span class=n>row</span><span class=p>(</span><span class=n>Result</span><span class=p>.</span><span class=n>rows</span> <span class=o>-</span> <span class=mi>1</span><span class=p>).</span><span class=n>setTo</span><span class=p>(</span><span class=n>Scalar</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
<span class=n>Result</span><span class=p>.</span><span class=n>col</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>setTo</span><span class=p>(</span><span class=n>Scalar</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
<span class=n>Result</span><span class=p>.</span><span class=n>col</span><span class=p>(</span><span class=n>Result</span><span class=p>.</span><span class=n>cols</span> <span class=o>-</span> <span class=mi>1</span><span class=p>).</span><span class=n>setTo</span><span class=p>(</span><span class=n>Scalar</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</code></pre></div><p>계산식의 특성상 맨 끝부분은 연산을 할수 없으므로 <strong>0</strong>을 대입해준다.</p><p>뭔가 그럴듯해보이는 함수지만 사실은 별거없는 함수다. 이런 간단한 연산을 할때 매번 이렇게 길게쓰는건 뭔가 시간낭비라고 OpenCV개발자들이 느꼈는지 <strong>kernel</strong>의 존재를 만들어내서</p><pre><code>filter2D(img, output, img.depth(), kern);
</code></pre><p>한방으로 계산을 끝내게 해주었다.
<code>filter2D</code>에 대한 자세한 정의는 <a class=link href=http://docs.opencv.org/modules/imgproc/doc/filtering.html#filter2d target=_blank rel=noopener>여기</a>를 참고하고 지금은 간단하게 설명하자면</p><p>img랑 output은 예상한것처럼 입력물과 출력물, img.depth()는 img의 저장형식 (CV_8U 같은거)를 리턴해준다, kern은 위에서 정의했다싶이</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Mat</span> <span class=n>kern</span> <span class=o>=</span> <span class=p>(</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>
            <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
            <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</code></pre></div><p>의 형태를 가지며 아래식의 행렬과 똑같이 생겼다.</p><p>여기서 주의해야할 사실은 여러분은 **Sharpen()**보단 <strong>filter2D</strong>를 사용해야된다는 것이다.</p><p>이유는 두가지이다.</p><ol><li>이게 더 구현하기 쉽다.</li><li>이게 3배정도 빠르다.</li></ol><p>참고로 이미 **Sharpen()**도 코드상 더이상 빨라질수가 없는데 실제로 더 빠른 이유는 <strong>filter2D</strong>는 <strong>어셈블리 단계에서 최적화</strong>도 되있을뿐아니라 <strong>SIMD</strong>와 같은 CPU의 특수기능들을 적극적으로 활용해 한번에 한 픽섹을 연산하는게 아니라, 한번에 여러픽셀을 동시에 연산하기 때문이다. **Sharpen()**은 그냥 참고용으로만 봐두고 실제 사용할때는 <strong>filter2D</strong>를 적극적으로 활용하도록 하자.</p><pre><code>**잠깐 쉬어가기**
cvtColor(img, img, CV_BGR2YCrCb);
inRange(img, Scalar(0, 133, 77), Scalar(255, 173, 127), output);
imshow(&quot;output&quot;, output);
이 코드를 실행해보자. 사람 피부색이 검출된다. 원리는 다음과 같다. BGR성분의 이미지를 색차와 휘도로 색공간을 나타내는 YCrCb로 변환한다음 여기서 (0,133,77)~(255,173,127)사이의 색만 골라서 출력하는 코드이다. 사람 피부색은 YCrCb로 표현했을때 특정 공간에 몰려있기에 가능한 것이다. RGB공간에서도 같은일을 할수있으나 YCrCb보단 정확도가 떨어진다. 단, 이 방법은 배경의 색차이때문에 나타나는 오류가 많기에 일반적인 상황에선 사용하지 않고 특수한 상황(공장에서 이미지기반 상품인식같은)에서 자주 쓰인다.
</code></pre><p><img src=./my.png alt>
*보다싶이 이 방법으로 **&ldquo;피부만&rdquo;*<em>인식하기는 힘들다.</em></p><h3 id=opencv에-있는-알고리즘-사용해보기>OpenCV에 있는 알고리즘 사용해보기</h3><p>작성중</p><p>-> 작성예정없음</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload="renderMathInElement(document.querySelector(`.article-content`));"></script></article><aside class="widget related-contents--wrapper"></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"wanhae"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><footer class=site-footer><section class=copyright>&copy; 2020 iWan</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=1.0.5>Stack</a></b> designed by
<a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true style=display:none><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script><link rel=stylesheet href=/css/highlight/light.min.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=/css/highlight/dark.min.css media="(prefers-color-scheme: dark)"></body></html>