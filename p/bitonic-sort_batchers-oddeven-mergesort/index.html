<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="구 블로그에서 가져옴"><title>Bitonic Sort (바이토닉 정렬) & batcher's oddeven mergesort</title><link rel=canonical href=https://blog.iwanhae.kr/p/bitonic-sort_batchers-oddeven-mergesort/><link rel=stylesheet href=/scss/style.min.css><meta name=google-site-verification content="hueaQ_HMu3Eq1ONg2Nh47uVN-tQXPzXlh1DXig6eT7c"><meta property="og:title" content="Bitonic Sort (바이토닉 정렬) & batcher's oddeven mergesort"><meta property="og:description" content="구 블로그에서 가져옴"><meta property="og:url" content="https://blog.iwanhae.kr/p/bitonic-sort_batchers-oddeven-mergesort/"><meta property="og:site_name" content="iWan"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2016-12-28T00:00:00+00:00"><meta property="article:modified_time" content="2016-12-28T00:00:00+00:00"><meta property="og:image" content="https://blog.iwanhae.kr/p/bitonic-sort_batchers-oddeven-mergesort/843px-BitonicSort1.svg.png"><meta name=twitter:title content="Bitonic Sort (바이토닉 정렬) & batcher's oddeven mergesort"><meta name=twitter:description content="구 블로그에서 가져옴"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.iwanhae.kr/p/bitonic-sort_batchers-oddeven-mergesort/843px-BitonicSort1.svg.png"></head><body><div class="container flex on-phone--column align-items--flex-start extended article-page with-toolbar"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hub2a4b6b69d3b0618960cb9af6c0975e0_643282_300x300_resize_box_2.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>😎️</span></figure><h1 class=site-name><a href=https://blog.iwanhae.kr>iWan</a></h1><h2 class=site-description>#include "Hi.h"</h2></header><ol class=menu id=main-menu><li><a href=https://blog.iwanhae.kr/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=https://blog.iwanhae.kr/welcome-to-iwan><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=https://blog.iwanhae.kr/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li></ol></aside><main class="main full-width"><div id=article-toolbar><a href=https://blog.iwanhae.kr class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><article class="has-image main-article"><header class=article-header><div class=article-image><img srcset="/p/bitonic-sort_batchers-oddeven-mergesort/843px-BitonicSort1.svg_huee9758fa79923c5c8964e6a4ad8e4967_32915_1024x0_resize_box_2.png 1024w, /p/bitonic-sort_batchers-oddeven-mergesort/843px-BitonicSort1.svg_huee9758fa79923c5c8964e6a4ad8e4967_32915_2000x0_resize_box_2.png 2000w" src=/p/bitonic-sort_batchers-oddeven-mergesort/843px-BitonicSort1.svg_huee9758fa79923c5c8964e6a4ad8e4967_32915_2000x0_resize_box_2.png width=843 height=258 loading=lazy alt="Featured image of post Bitonic Sort (바이토닉 정렬) & batcher's oddeven mergesort"></div><div class=article-details><header class=article-category><a href=https://blog.iwanhae.kr/categories/algorithm/ class=color-tag data-image=/p/bitonic-sort_batchers-oddeven-mergesort/843px-BitonicSort1.svg_huee9758fa79923c5c8964e6a4ad8e4967_32915_20x20_fill_box_smart1_2.png data-key=bitonic-sort_batchers-oddeven-mergesort data-hash="md5-oWcwka8X1grfox9Qzr3uxw==">Algorithm</a></header><h2 class=article-title><a href=https://blog.iwanhae.kr/p/bitonic-sort_batchers-oddeven-mergesort/>Bitonic Sort (바이토닉 정렬) & batcher's oddeven mergesort</a></h2><h3 class=article-subtitle>구 블로그에서 가져옴</h3><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>2016년 12월 28일</time></footer></div></header><section class=article-content><h2 id=서론>서론</h2><p>정렬알고리즘 뭐가좋아요? 라고 물어본다면</p><p>뭐 데이터 개수나 컴퓨터 성능의 제약등 이것저것 따져봐야할께 많이 있기는 하지만 일반적으로 Quick Sort면 대충 해결된다.</p><p>하지만, 시대는 더이상 **&ldquo;단일 스레드를 빠르게!!"**가 아닌 **&ldquo;엄청 많은 스레드를 같이!!"**의 시대로 변해버렸다.</p><p>요즘 대표적인 예가 GPGPU를 활용한 머신러닝 근사값찾기 노가다다.</p><p>뭐 그런거 요즘 생각하면서 심심풀이로 CUDA라이브러리 뒤적뒤적하다보니 OpenCL이 튀어나오고 OpenCL뒤적뒤적하다보니 Boost가 튀어나오는데 이놈 뒤적뒤적하다보니&mldr;&mldr;.</p><p>음? GPU써서 정렬했는데 훨씬 빠르다고?<del>그전에 GPU써서 정렬이 가능해? 항상 Matrix계산만 시켰는데?</del></p><p>그거 생각하고 또 뒤적뒤적하다보니 찾아낸게 <strong>Bitonic Sort</strong>와 <strong>oddeven mergesort</strong> 이다.</p><h2 id=간단-소개>간단 소개</h2><p>둘다 같은사람이 만들었고, 둘다 <strong>시간복잡도</strong>가 **Olog^2(n)**로 QuickSort가 평균 <strong>Onlogn</strong>인거 생각하면 무척 빠른편에 속한다.</p><p><del>(헌데 oddeven mergesort쪽이 Bitonic Sort에 비해 연산량이 더 적다. 데이터 수에따라 다르지만 보통 5-20%정도 더 적다. 데이터가 커질수록 둘이 별 차이 없어지지만)</del></p><p>근데 왜 덜유명하냐면 <strong>공간복잡도</strong>가 **Onlog^2(n)**로 큰편에 속한다.</p><p>하지만 병렬화가 무척이나 쉬운편에 속해서 멀티코어는 물론이요 GPU에도 써먹을수 있을정도라서 GPGPU분야에서 입문쯤에 존재하는 알고리즘이다.</p><p>참고로 이놈들은 <strong>Sorter</strong>나 <strong>Sorting Network</strong>라는 표현으로도 불리는데 그 이유가 <strong>Quick Sort</strong>처럼 데이터에따라 pivot이 달라지고 어떤 배열에서 몇번째데이터랑 몇번째데이타랑 비교할지가 바뀌는게 아니라 <strong>데이터에 상관없이</strong> 항상 몇번째 데이터랑 몇번째 데이터랑 비교할지 이미 정해져 있어서 그렇다고 한다.</p><h2 id=bitonic-sort>Bitonic Sort</h2><p>일단 코드부터 (C#)</p><div class=highlight><pre class=chroma><code class=language-c# data-lang=c#><span class=k>class</span> <span class=nc>Program</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>a</span><span class=p>;</span> <span class=c1>//실제 데이터
</span><span class=c1></span>    <span class=k>static</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>b</span><span class=p>;</span> <span class=c1>//변하는거 표시용 (안중요)
</span><span class=c1></span>
    <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>(</span><span class=kt>string</span><span class=p>[]</span> <span class=n>args</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>a</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[]</span> <span class=p>{</span> <span class=m>9</span><span class=p>,</span> <span class=m>6</span><span class=p>,</span> <span class=m>8</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=m>10</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>7</span><span class=p>,</span> <span class=m>2</span> <span class=p>,</span><span class=m>16</span> <span class=p>,</span><span class=m>13</span> <span class=p>,</span><span class=m>14</span> <span class=p>,</span><span class=m>15</span> <span class=p>,</span><span class=m>11</span> <span class=p>,</span><span class=m>12</span> <span class=p>};</span>
        <span class=n>b</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[]</span> <span class=p>{</span> <span class=m>9</span><span class=p>,</span> <span class=m>6</span><span class=p>,</span> <span class=m>8</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=m>10</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>7</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>16</span><span class=p>,</span> <span class=m>13</span><span class=p>,</span> <span class=m>14</span><span class=p>,</span> <span class=m>15</span><span class=p>,</span> <span class=m>11</span><span class=p>,</span> <span class=m>12</span> <span class=p>};</span>
        <span class=n>print</span><span class=p>();</span>
        <span class=n>BitonicSort</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>a</span><span class=p>.</span><span class=n>Length</span><span class=p>,</span> <span class=k>true</span><span class=p>);</span>
        <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>static</span> <span class=k>void</span> <span class=n>BitonicSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isAscending</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=p>==</span> <span class=m>1</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>m</span> <span class=p>=</span> <span class=n>n</span> <span class=p>/</span> <span class=m>2</span><span class=p>;</span>
        <span class=n>BitonicSort</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=k>true</span><span class=p>);</span>    <span class=c1>//앞에 반쪽 오름차순 정렬
</span><span class=c1></span>        <span class=n>BitonicSort</span><span class=p>(</span><span class=n>start</span><span class=p>+</span><span class=n>m</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=k>false</span><span class=p>);</span> <span class=c1>//뒤에 반쪽 내림차순 정렬
</span><span class=c1></span>
        <span class=cm>/*
</span><span class=cm>        결과적으로
</span><span class=cm>            ↗↘
</span><span class=cm>          ↗    ↘
</span><span class=cm>        이런모양이 완성됨.
</span><span class=cm>        */</span>

        <span class=n>BitonicMerge</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>isAscending</span><span class=p>);</span>    <span class=c1>//합치기
</span><span class=c1></span>    <span class=p>}</span>

    <span class=k>static</span> <span class=k>void</span> <span class=n>BitonicMerge</span><span class=p>(</span><span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isAscending</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=p>==</span> <span class=m>1</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>m</span> <span class=p>=</span> <span class=n>n</span> <span class=p>/</span> <span class=m>2</span><span class=p>;</span>

        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=n>start</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>start</span> <span class=p>+</span> <span class=n>m</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>            
            <span class=n>compare</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>i</span> <span class=p>+</span> <span class=n>m</span><span class=p>,</span> <span class=n>isAscending</span><span class=p>);</span>
        <span class=c1>//이렇게 함으로써 앞에반쪽의 모든성분은
</span><span class=c1></span>        <span class=c1>//뒤에 반쪽의 성분보다 작게됨.
</span><span class=c1></span>
        <span class=cm>/*
</span><span class=cm>        결과적으로
</span><span class=cm>            ↗↘       ↘    ↗
</span><span class=cm>          ↗    ↘ 혹은  ↘↗
</span><span class=cm>        이랬던게
</span><span class=cm>              ↘↗
</span><span class=cm>          ↗↘||||
</span><span class=cm>        이런모양으로 됨.
</span><span class=cm>        */</span>

        <span class=n>BitonicMerge</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>isAscending</span><span class=p>);</span>    <span class=c1>//앞의 반쪽 계속 Merge
</span><span class=c1></span>        <span class=n>BitonicMerge</span><span class=p>(</span><span class=n>start</span><span class=p>+</span><span class=n>m</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>isAscending</span><span class=p>);</span>  <span class=c1>//뒤의 반쪽 계속 Merge
</span><span class=c1></span>
    <span class=p>}</span>
    <span class=k>static</span> <span class=k>void</span> <span class=n>compare</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isAscending</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>isAscending</span> <span class=p>==</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>]))</span>
        <span class=p>{</span>
            <span class=n>exchange</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
            <span class=n>print</span><span class=p>();</span>
        <span class=p>}</span>                
    <span class=p>}</span>

    <span class=k>static</span> <span class=k>void</span> <span class=n>exchange</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=kt>int</span> <span class=n>t</span> <span class=p>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
        <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=p>=</span> <span class=n>t</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>static</span> <span class=k>void</span> <span class=n>print</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>a</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
        <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>!=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
            <span class=p>{</span>
                <span class=n>Console</span><span class=p>.</span><span class=n>Write</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>+</span> <span class=s>&#34;*\t&#34;</span><span class=p>);</span>
                <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
            <span class=p>}</span>
            <span class=k>else</span>                
                <span class=n>Console</span><span class=p>.</span><span class=n>Write</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>+</span> <span class=s>&#34;\t&#34;</span><span class=p>);</span>                             
        <span class=p>}</span>
        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>();</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>성분이 2^n 개가 아니라면 좀 상황이 미묘해진다는점 빼고 심플(?)한 코드이다.</p><p>좀 생각해보면 알 수 있다싶이 데이터의 성분에 상관없이 항상 비교하는 대상이 정해져있어서 다음과 같은 그림으로도 표현된다.</p><p><img src=./843px-BitonicSort1.svg.png alt></p><p>(<a class=link href=https://en.wikipedia.org/wiki/Bitonic_sorter target=_blank rel=noopener>위키피디아</a>에서 가져옴)</p><p>그리고 이렇게 <strong>data-independent</strong> ~~(한국어로 뭐라할지 미묘&mldr;..)~~<del>데이터 독립적? 멋없어&mldr;.</del> 하다보니깐</p><p>작업분배가 편하고 거의 모든과정이 병렬화가 가능해서 <del>(Sync과정이 꽤 필요하긴 하지만)</del></p><p>GPGPU, 즉 GPU를 활용해서 정렬하는것이 가능하다.<del>(데이터수가 1024^2개가 넘어가면 CPU보다 눈에띄게 빠르다고 한다.)</del></p><p>(보통 batcher&rsquo;s oddeven mergesort 를 더 많이 쓴다는듯 하다.)</p><h2 id=batchers-oddeven-mergesort>batcher&rsquo;s oddeven mergesort</h2><p>작성중&mldr;.</p><p>-> 작성예정 없음</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload="renderMathInElement(document.querySelector(`.article-content`));"></script></article><aside class="widget related-contents--wrapper"><h1 class=widget-title></h1><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=https://blog.iwanhae.kr/p/introduction-of-unity-dots/><div class=article-image><img src=/p/introduction-of-unity-dots/unity_hu1c9b8fcd35819c4b7bef60354e8d91e1_51979_250x150_fill_box_smart1_2.png width=250 height=150 loading=lazy data-key=introduction-of-unity-dots data-hash="md5-Q36/TZZwH5wUa/JBI/d3Uw=="></div><div class=article-details><h2 class=article-title>원리부터 파악하는 Unity의 DOTS</h2></div></a></article><article class=has-image><a href=https://blog.iwanhae.kr/p/introduction_of_bitcoin/><div class=article-image><img src=/p/introduction_of_bitcoin/8369-bitcoin_102502_hu90eb6f978434e4f2793dc035066ad0c0_11943_250x150_fill_box_smart1_2.png width=250 height=150 loading=lazy data-key=introduction_of_bitcoin data-hash="md5-MFi2BnaKEV9GNGPQgBep2Q=="></div><div class=article-details><h2 class=article-title>원리부터 파악하는 비트코인</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"wanhae"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><footer class=site-footer><section class=copyright>&copy; 2021 iWan</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=1.0.5>Stack</a></b> designed by
<a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true style=display:none><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script><link rel=stylesheet href=/css/highlight/light.min.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=/css/highlight/dark.min.css media="(prefers-color-scheme: dark)"></body></html>