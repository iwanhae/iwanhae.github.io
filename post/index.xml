<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on iWan</title><link>https://iwanhae.github.io/post/</link><description>Recent content in Posts on iWan</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 02 Jul 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://iwanhae.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Odroid N2, Linux에서 UAS 비활성화</title><link>https://iwanhae.github.io/p/disabling_uas_on_linux/</link><pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/disabling_uas_on_linux/</guid><description>서론 외장하드 기능을 보다보면 간혹 UAS 혹은 UASP라고 불리는 기능이 있다. USB Attached SCSI 라는놈인데 이름 그대로 SCSI 기술을 USB를 통해 사용하겠다는건데
왜 USB를 그냥 USB로 안쓰고 이렇게 번거롭게 SCSI명령어로 바꾼다음에 보내냐면 이게 더 빠르기 때문이다.
정확히는 SCSI의 경우 별도의 컨트롤러가 명령어를 하드웨어레벨로 처리하기때문에 CPU가 데이터를 USB명령어에 맞게 인코드해서 보내줄필요 없이 CPU는 그냥 데이터를 메모리상에 올려두기만 하면 나머지는 컨트롤러가 알아서 외부 디바이스로 보내주기땜에 CPU로드가 훨씬 적고 거의 대부분의 경우 병목현상이 없기때문에 훨씬 빠르다.</description></item><item><title>리눅스, 하드디스크를 절전모드로 두기 (hdparm)</title><link>https://iwanhae.github.io/p/introducing-hdparm/</link><pubDate>Sat, 12 Dec 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/introducing-hdparm/</guid><description>서론 요런식으로 서버를 운영하다보니 하드디스크 돌아가는 소리가 좀 거슬린다&amp;hellip;. (특히나 소음 심하다는 Hitachi제 하드디스크&amp;hellip;.)
그래서 하드디스크를 절전상태로 두는 간단한 방법을 소개한다.
본론 일단 하드디스크를 절전상태로 들어가게해주는 &amp;ldquo;hdparm&amp;rdquo; 을 각자 알아서 설치해 주자. 대중적인 프로그램이니깐 기본적으로 설치되있는 경우도 꽤 많고 설치되있지 않다해도 apt나 yum으로 쉽게 설치 가능하다.
그 후 자신의 설정할 하드디스크의 경로를 알아내자. ROOT권한으로 fdisk -ls를 입력하면 현재 인식되있는 모든 저장장치의 정보를 볼수있다.
Disk /dev/sda: 320.1 GB, 320072933376 bytes 255 heads, 63 sectors/track, 38913 cylinders, total 625142448 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0xf83c5fbd Device Boot Start End Blocks Id System /dev/sda1 2048 625141759 312569856 83 Linux /dev/sda1은 파티션에 관한 정보고 여기서 필요한건 /dev/sda이다.</description></item><item><title>원리부터 파악하는 OpneCV</title><link>https://iwanhae.github.io/p/introduction-to-opencv/</link><pubDate>Sat, 03 Oct 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/introduction-to-opencv/</guid><description>서론 OpenCV에 대해 포스팅되는 글들에대해 개인적으로 분류를 해보자면 크게 두가지 부류가 있다. 하나는 &amp;ldquo;나도 이게 어떻게 되는지는 모르지만 일단 되는류&amp;rdquo; 고 나머지 하나는 &amp;ldquo;난 이미 너무 자세히 알고있어서 기초에대해 포스팅할 마음이 안생기는류&amp;ldquo;이다.
이것이 진실로 그러하든 그러하지않던 초보자에게 한글로된 문서만 보고 OpenCV입문이란 힘든다는것은 아마 대부분의 사람들이 공감할것이라 믿는다.
그래서 비교적 최신버전(3.0)에 기초하여 OpenCV가 사용하는 기본적인 함수부터 개발자가 이러한 함수를 만든 의도까지 살려서 C++ 혹은 객체지향언어의 본질을 깨달은 사람을 대상으로 &amp;ldquo;이정도 이해했으면 나머지는 알아서 할수있겠지!</description></item><item><title>공기저항을 고려한 자유낙하</title><link>https://iwanhae.github.io/p/free-fall-with-air-resistance/</link><pubDate>Tue, 22 Sep 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/free-fall-with-air-resistance/</guid><description>k는 현재의 공기저항 상수 s는 거리 v는 속도 a는 가속도 F는 힘 g는 중력가속도 공기저항은 속도 제곱에 비례하다는 가정하에 다음과 같은 결과가 나온다.
$$F\quad =\quad ma\quad =\quad mg-k{ v }_{ }^{ 2 }$$
$$a\quad =\quad \frac { mg\quad -\quad k{ v }^{ 2 } }{ m } \quad =\quad g-\frac { k{ v }^{ 2 } }{ m } \quad =\frac { dv }{ dt } $$
$$dv\quad =\quad (g-\frac { kv }{ m } )dt$$</description></item><item><title>엔트로피 인코딩 (엔트로피 부호화)</title><link>https://iwanhae.github.io/p/entropy_encoding/</link><pubDate>Mon, 21 Sep 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/entropy_encoding/</guid><description>무손실 압축같은 분야에서 애용되는 기법으로
여기서 엔트로피(entropy)는
&amp;lt;통신&amp;gt; 정보량의 기대치를 이르는 말. [비슷한 말] 평균 정보량. 이라는 의미로 사용된다.
말그대로 기대되는 정보량에대해 부호화(encoding)을 한다는것이다.
예를들면
10001010110101001111010100000 같은걸
1(0, 3개)(10,2개)1(10,2개).....(0,5개) 와 같이 부호화 해준다는 거다.
대표적 엔트로피 인코딩 기법으론 허프만 부호화, 범위 부호화와 산술 부호화, 런 렝스 코딩 등이 있다.</description></item><item><title>우분투 서버 한글화 절차</title><link>https://iwanhae.github.io/p/locale_setting/</link><pubDate>Sun, 20 Sep 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/locale_setting/</guid><description>apt-get install language-pack-ko locale-gen ko_KR.UTF-8 LANG=ko_KR.URF-8 LANGUAGE=ko_KR:ko:en_GB:en 그후 /etc/default/locale 에다가
LANG=ko_KR.UTF-8 추가해준뒤 재부팅
locale 커맨드로 ko_KR.UTF-8가 제대로 설정되었는지 확인.
14.04버전 기준이다. Debian계열에선 전부 작동한다.</description></item></channel></rss>