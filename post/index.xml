<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on iWan</title><link>https://iwanhae.github.io/post/</link><description>Recent content in Posts on iWan</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 02 Jul 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://iwanhae.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Odroid N2, Linux에서 UAS 비활성화</title><link>https://iwanhae.github.io/p/disabling_uas_on_linux/</link><pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/disabling_uas_on_linux/</guid><description>서론 외장하드 기능을 보다보면 간혹 UAS 혹은 UASP라고 불리는 기능이 있다. USB Attached SCSI 라는놈인데 이름 그대로 SCSI 기술을 USB를 통해 사용하겠다는건데
왜 USB를 그냥 USB로 안쓰고 이렇게 번거롭게 SCSI명령어로 바꾼다음에 보내냐면 이게 더 빠르기 때문이다.
정확히는 SCSI의 경우 별도의 컨트롤러가 명령어를 하드웨어레벨로 처리하기때문에 CPU가 데이터를 USB명령어에 맞게 인코드해서 보내줄필요 없이 CPU는 그냥 데이터를 메모리상에 올려두기만 하면 나머지는 컨트롤러가 알아서 외부 디바이스로 보내주기땜에 CPU로드가 훨씬 적고 거의 대부분의 경우 병목현상이 없기때문에 훨씬 빠르다.</description></item><item><title>Netplan Bridge 구성기</title><link>https://iwanhae.github.io/p/config-netplan-bridge/</link><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/config-netplan-bridge/</guid><description>서론 우분투가 netplan을 사용한지는 꽤 된걸로 알고있다. 17.04 부터 였던가? 아마 그쯤이었던걸로 기억한다. 그냥 알던데로 ifup, ifdown 명령어를 쓰거나 /etc/network에 들어가서 네트워크 설정을 분명 수정했는데 제대로 반영이 안되서 멘붕왔던게 지금도 기억난다. ㅋㅋㅋ&amp;hellip;..ㅠ
뭐 그건 그때고, netplan을 한번 알고나니깐 이렇게 직관적이고 간편한것도 없다는게 지금생각이다. 덕분에 CentOS쪽을 사용도 못해보겠다는게 함정이라면 함정이지만 말이다.
그런 느낌으로 지내오다가 요즘 VM 가지고 놀다가 자체 NAT으로 돌리자니 불편한점이 너무 많고 어차피 iptime 공유기 안쪽에서 노는건데 ip관리는 전부 공유기한테 시키고 Host는 가상머신만 구동시키라는 느낌으로 브릿지 구성하면서 뻘짓들 기록으로좀 남겨본다.</description></item><item><title>원리부터 파악하는 Unity의 DOTS</title><link>https://iwanhae.github.io/p/introduction-of-unity-dots/</link><pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/introduction-of-unity-dots/</guid><description>서론 필자는 원래 게임을 별로 즐겨하는 성격이 아니기에 Unity에 별 관심이 없었다.
데이터 시각화 수단으로써 잠깐 관심을 가졌던적이 있긴 하지만 그것도 잠시 훌륭한 Javascript 라이브러리들이 무식하게 커다란 데이터도 효율적으로, 구현하기 쉽게 시각화 수단을 제공하면서 이에대한 관심도 금방 사라졌다. (아무래도 Unity는 Restful한게 기본은 아니기에&amp;hellip;.)
그렇게 관심이 없어지면서 2018년까지 필자의 Unity에 대한 생각은
싱글스레드로 무식하게 물리연산해가면서 컴퓨터 리소스 우걱우걱 처먹고 틈만나면 램 처묵처묵하면서 버그 내뿜는 이상한 놈이지만 공짜에다 개발이 편해서 게임 개발자들에게 사랑받는 존재.</description></item><item><title>Freenom 도메인 갱신하는법</title><link>https://iwanhae.github.io/p/renewing_freenom_domain/</link><pubDate>Wed, 20 Dec 2017 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/renewing_freenom_domain/</guid><description>서론 매년 12월마다 iwanhae.ga 도메인을 갱신하는일을 벌써 3번째 해보는데 할때마다 까먹고 Ticket만들어서 어떻게 하냐고 물어보는거 짜증나서 적어둔다.
본론 알아두어야 할 점은
Expire되기 14일 전 부터 갱신가능 최대 12개월 연장가능 연장횟수는 무제한 Expire 되기전에 Renew하지 못하면 몇달동안 해당 도메인은 유료가 되버려서 결국 카드결제 해야됨 정도고 방법은
http://www.freenom.com 에 들어가면 요런 메인페이지가 나오는데 요기에 Renew 버튼이 있다.
그리고 Renew하면 된다.
끗
후기 사실 이분 너무 안쓰러워서 작성함&amp;hellip;&amp;hellip;</description></item><item><title>사이버 지식 정보방 (사지방) 구글 접속기</title><link>https://iwanhae.github.io/p/saga_of_wanhae_the_googler/</link><pubDate>Tue, 24 Oct 2017 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/saga_of_wanhae_the_googler/</guid><description>서론 군인이다&amp;hellip;.
비록 군대에 있긴하지만 일과시간만 벗어나면 어느정도 자유시간이 보장되며 필자도 정기적으로 사지방에 와서 인터넷 세계를 맛볼수 있다.
다만 문제가 되는게&amp;hellip;&amp;hellip;.
80번 443번 포트를 제외하고 모두 막혀있음 구글 접속이 안됨 1번은 일반적으로 크게 문제되는일은 없겠지만 필자의경우 ssh 접속에 제한되어 큰 골칫거리였다. 이에대한 해결법은 여기를 참고하기 바란다.
2번은 비교적 최근 완전한 해결법을 발견해 그에대해 설명해보고자 한다.
본론 사지방에서 구글이 안되는이유는 크게 두가지정도로 추정된다.
이유 1, DNS의 오류 하나는 DNS정보를 잘못받아온다.</description></item><item><title>ShellinaBox 웹에서 즐기는 터미널</title><link>https://iwanhae.github.io/p/shellinabox/</link><pubDate>Sun, 01 Oct 2017 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/shellinabox/</guid><description>서론 지금 필자는 군인이다. 군대에 있다.
다행이도 보직을 그런쪽으로 받아서 그런지 컴퓨터를 사용할 기회가 많으며 여가시간을 이용해 군대내 인트라넷이 아닌 외부 인터넷에 접속할 기회도 많다.
단지 문제가 있는건&amp;hellip;&amp;hellip; 열려있는 포트가 80이랑 443밖에 없다&amp;hellip;..
아시는분은 이미 알고있겠지만 이 두 포트는 일반적인 http 통신포트와 https통신포트로 즉, 웹서핑 이외에는 할수있는게 거의 없다.
일반적인 유저라면 이는 별 문제가 되지 않겠지만&amp;hellip;&amp;hellip; 필자에게 한가지 문제가 있는데 SSH가 안된다&amp;hellip;. (이놈은 22번 포트사용)
이런 상황에서 웹에서 터미널을 이용할 방법을 찾으며 여러가지 삽질을 하다가 찾아낸게 ShellInABox이다.</description></item><item><title>원리부터 파악하는 비트코인</title><link>https://iwanhae.github.io/p/introduction_of_bitcoin/</link><pubDate>Fri, 24 Feb 2017 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/introduction_of_bitcoin/</guid><description>https://git.iwanhae.ga/wan/introduction_of_bitcoin
서론 지금 (2016년 12월) 우리나라는 비트코인 열기가 한풀 꺽인 참이지만 세계적으로, 특히 중국의 경우 왠지모르게 엄청난 채굴경쟁과 함께 (사실 세계라긴보단 중국 내에서 열풍인데 총 채굴성능의 50% 이상이 중국에서 나옴) (일본도 약간 유행중.) 그 시세가 엄청 올랐다.
그 이유는 모르겠지만 생각난김에 비트코인을 처음보는사람이 이 포스트만보고 프로토타입을 구현할 수 있을정도의 설명을 적어보자 한다.
(이 글은 심심할때마다 조금씩 써집니다.)
(진부하지만 글 시작하기에 좋은) 비트코인이란? 비트코인은 세계최초의 암호화폐, 세계최초의 비 중앙집권적 금용시스템, 블록체인을 실용화시켜 엄청나게 극단적인 사람들의 경우 &amp;ldquo;4차 산업혁명을 앞당기는데 중대한 역할을 함!</description></item><item><title>Bitonic Sort (바이토닉 정렬) &amp; batcher's oddeven mergesort</title><link>https://iwanhae.github.io/p/bitonic-sort_batchers-oddeven-mergesort/</link><pubDate>Wed, 28 Dec 2016 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/bitonic-sort_batchers-oddeven-mergesort/</guid><description>서론 정렬알고리즘 뭐가좋아요? 라고 물어본다면
뭐 데이터 개수나 컴퓨터 성능의 제약등 이것저것 따져봐야할께 많이 있기는 하지만 일반적으로 Quick Sort면 대충 해결된다.
하지만, 시대는 더이상 **&amp;ldquo;단일 스레드를 빠르게!!&amp;quot;**가 아닌 **&amp;ldquo;엄청 많은 스레드를 같이!!&amp;quot;**의 시대로 변해버렸다.
요즘 대표적인 예가 GPGPU를 활용한 머신러닝 근사값찾기 노가다다.
뭐 그런거 요즘 생각하면서 심심풀이로 CUDA라이브러리 뒤적뒤적하다보니 OpenCL이 튀어나오고 OpenCL뒤적뒤적하다보니 Boost가 튀어나오는데 이놈 뒤적뒤적하다보니&amp;hellip;&amp;hellip;.
음? GPU써서 정렬했는데 훨씬 빠르다고?그전에 GPU써서 정렬이 가능해? 항상 Matrix계산만 시켰는데?
그거 생각하고 또 뒤적뒤적하다보니 찾아낸게 Bitonic Sort와 oddeven mergesort 이다.</description></item><item><title>Systemd를 이용한 rc.local활성화 (우분투 16.10)</title><link>https://iwanhae.github.io/p/rc-local_systemd/</link><pubDate>Wed, 28 Dec 2016 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/rc-local_systemd/</guid><description>서론 좀 전부터 systemd가 흥하다 싶더니 순식간에 레드헷계열은 물론이요 데비안도 전부 systemd를 사용하게 되었습니다.
Systmed란?(ZDnet기사)
사실 전 이런거에 별로 익숙치 않아서 여태껏 별로 신경쓰지 않고 기존 시스템을 사용해 왔는데&amp;hellip;&amp;hellip;. 얼마전 서버를 아폴로 레이크로 바꾸니깐 커널이 4.8부터 지원하고(&amp;hellip;) 그거 되는 서버가 우분투 16.10밖에 없고(&amp;hellip;) 우분투 16.10은 완벽하게 systemd사용하고 있고(&amp;hellip;)
근데 그 무엇보다&amp;hellip;.. RC.LOCAL이 비활성화가 기본이더군요&amp;hellip;..
뭐 솔직히 systemd가 좋긴 좋아요. 로깅도 자동으로 되고, 꺼져도 알아서 다시 켜지게 할 수도 있고, 예약도 훨씬더 편하게 설정해 놓을수 있고, 의존성 문제 해결도 쉬워요.</description></item><item><title>뒤에서 부터 보는 C언어: 1. 기본적인것들</title><link>https://iwanhae.github.io/p/clang_from_backward_1/</link><pubDate>Tue, 27 Dec 2016 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/clang_from_backward_1/</guid><description>서론 C언어는 아무도 이의를 제기할 수 없을정도로 장수한 프로그래밍 언어중 가장 인기가 높은 언어이다. 그리고 또한 C언어를 프로그래밍 언어의 입문으로 생각하여 처음 접하는 언어로 C언어를 택하는 사람도 많다고 생각된다.
하지만 이러한 현실 속에서 실질적으로 C언어에대한 책이나 강의를 보면 하나같이 다 똑같다.
printf(&amp;ldquo;뭔가 이상한 %나 &amp;amp;가 섞여있는 문자열&amp;rdquo;, 변수여러개);
요렇게 치면 놀랍게도 까만색창에 문자가 떠여~!!!! 와 박수~!
필자는 Visual Basic으로 프로그래밍을 입문해서 그런지, 이러한 가르켜주는 방식은 발전 가능성도 없으며 (솔직히 이것만보고 운영체제에서 지정해준 버퍼에 내용을 쓰면 운영체제가 하나하나 읽어가며 화면에 표시해준다는걸 누가 알겠는가?</description></item><item><title>뒤에서 부터 보는 C언어: 2. 변수</title><link>https://iwanhae.github.io/p/clang_from_backward_2/</link><pubDate>Tue, 27 Dec 2016 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/clang_from_backward_2/</guid><description>변수란 무엇인가? 변수, 영어로는 Variable, Vary(달라지다) + able(가능하다)
뭐 대충 한번쯤 써본적은 있을테니 알꺼라 믿지만 (컴퓨터 아니라도 수학에서 허구한날 쓰니깐) 그래도 고전적이게 한번 써보자면 이것은 그릇이다.
그릇 안에는 0과 1의 조합이 들어있고 그릇에는 그릇 고유의 이름과 그릇의 특성이 있는데 이름은 사용자가 맘대로 정하는거고 그릇의 특성에따라 컴퓨터가 해석하는 방법이 달라진다.
만약 char 특성이면 문자~~(사실 1바이트 숫자지만)~~, INT 특성이면 정수, Float 특성이면 실수, Bool 특성이면 True,False ~~헌데 C언어는 Bool없다&amp;hellip;.. _Bool은 GCC에선 있다.)~~</description></item><item><title>nginx 개인서버에 HTTPS(TLS/SSL) 적용하기 (CA 없이)</title><link>https://iwanhae.github.io/p/nginx-ssl-https/</link><pubDate>Wed, 21 Sep 2016 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/nginx-ssl-https/</guid><description>서론 필자가 다니는 학교 wifi는 교내라면 어디서든 심지어 야외에서도 빵빵하게 터지는 엄청난 장점과 함께 크나큰 단점이 한가지 있는데&amp;hellip;..
라우터에서 http 통신내역을 까봐서 이것이 윈도우이면 보안을 위해 특정 프로그램을 설치하라는 홈페이지로 강제 리다이렉트 시킨다는 점이다.
물론 &amp;ldquo;그냥 깔면 되는거 아니에요?&amp;rdquo; 하겠지만&amp;hellip;.. 이놈이 윈도 XP용으로 맞춰 만들어져 있어서 윈도 7, 8.1, 10에서는 깔기만해도 블루스크린으로 만들어주는 아주 대단한 놈이다.
이에대한 대응으로 VPN을 쓴다던가 우분투를 쓴다던가 크롬을 개조해서 http요청헤더에서 윈도부분만 쏙 빼는 별 여러가지 방법을 써봤지만 뭔가 느려지기도 하고 일일히 설정하는게 귀찮아지기도 하고 윈도가 편하고&amp;hellip;.</description></item><item><title>(X11 Forwarding) Putty, GUI, SSH</title><link>https://iwanhae.github.io/p/x11-forwarding/</link><pubDate>Wed, 03 Feb 2016 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/x11-forwarding/</guid><description>서론 본인은 리눅스 조작할때 어지간해서는 GUI로 안하고 SSH로 접속해 콘솔환경으로 전부 끝내는 경향이 있다. 이유는 여러가지 있지만 가장 큰 이유는 아마 리눅스 GUI의 미묘하게 불편한 응답속도에 있다. 리눅스가 원래 GUI환경이 있을꺼란 전재하에 만들어진 운영체제가 아니다보니 윈도나 맥에비해 미묘한 딜레이가 있는데 개인적으로 이 이질감이 싫어 리눅스에서 GUI는 거의 안쓴다. (리눅스 콘솔은 가끔쓰지만 보통은 윈도에서 SSH환경을 더 선호한다.)
하지만 작업을 하다보면 GUI가 훨씬더 편할때가 꼭 있다. 예를들면 하드용량 확보할때 Baobab을 써 각 폴더의 상태를 보며 작업하면 무지 편하고 cmake할때 일일히 옵션들을 켤지 끌지 정해주는것보다 마우스로 클릭클릭하며 정해주는게 더 편하다.</description></item><item><title>라즈베리파이에서 FFMPEG로 인코딩 하기</title><link>https://iwanhae.github.io/p/pi-ffmpeg/</link><pubDate>Sat, 09 Jan 2016 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/pi-ffmpeg/</guid><description>서론 현재 본인은 이 블로그서버를 운영하며 친구들, 지인끼리 동영상공유로도 사용하고 있다. 문제가 있다면 코덱이 워낙 다양한탓에 HTML5로 재생이 안되던가 스마트폰으로 스트리밍으로 재생하기에는 너무 무거운 동영상들이 있다는 것이다. 보통은 해당영상을 다른버전으로 다운받아 해결하지만 그게 힘들경우 따로 인코딩을 하는데 지금부터 라즈베리파이에서 인코딩을 하는법을 소개하겠다.
하는것은 자유지만 미리 말해두자면 라즈베리 파이의 성능이 성능인만큼 꽤 느리다. 보통 0.12배속으로 인코딩이 진행되는데 24분짜리 영상 인코딩하는데 3~4시간정도 걸린다. (참고로 오드로이드 XU4의 경우 1.1배속정도 나온다.)(단점은 쿨러소리가 상당하다는점)
준비물 보통 대부분은 있지만 일부 배포판의경우 배포 용량을 줄이기위해 자주 빠지는 패키지들을 설치해주자.</description></item><item><title>우분투, NFS 설정</title><link>https://iwanhae.github.io/p/nfs_guideline/</link><pubDate>Sun, 03 Jan 2016 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/nfs_guideline/</guid><description>서버쪽 apt-get install nfs-common nfs-kernel-server rpcbind
설치 완료후
/etc/exports
파일을 수정
/home/test/testfolder
를 공유한다 가정할때
마지막줄에
/home/test/testfolder 192.168.0.X(rw, no_root_squash, sync)[/경로] [허용할 IP주소. *은 모두허용](옵션들)
와 같은 줄을 추가. (IP주소와 옵션은 붙어있다. 띄어쓰기하면 기본값으로 열리니 주의)
옵션은 다음과 같은 선택지가 있음
ro : 읽기 전용 rw : 읽기 및 쓰기 가능 no_root_squash : 클라이언트쪽 root도 서버쪽 root와 같은권한가짐 no_all_squash : root이외 모든사용자에대해 UID가 같으면 같은권한을가짐 sync : 서버와 클라이언트사이에 sync를 맞춤 insecure : 인증안되도 접속허가 설정해준뒤service nfs-kernel-server restartservice rpcbind restart로 서버 재시작</description></item><item><title>리눅스, 하드디스크를 절전모드로 두기 (hdparm)</title><link>https://iwanhae.github.io/p/introducing-hdparm/</link><pubDate>Sat, 12 Dec 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/introducing-hdparm/</guid><description>서론 요런식으로 서버를 운영하다보니 하드디스크 돌아가는 소리가 좀 거슬린다&amp;hellip;. (특히나 소음 심하다는 Hitachi제 하드디스크&amp;hellip;.)
그래서 하드디스크를 절전상태로 두는 간단한 방법을 소개한다.
본론 일단 하드디스크를 절전상태로 들어가게해주는 &amp;ldquo;hdparm&amp;rdquo; 을 각자 알아서 설치해 주자. 대중적인 프로그램이니깐 기본적으로 설치되있는 경우도 꽤 많고 설치되있지 않다해도 apt나 yum으로 쉽게 설치 가능하다.
그 후 자신의 설정할 하드디스크의 경로를 알아내자. ROOT권한으로 fdisk -ls를 입력하면 현재 인식되있는 모든 저장장치의 정보를 볼수있다.
Disk /dev/sda: 320.1 GB, 320072933376 bytes 255 heads, 63 sectors/track, 38913 cylinders, total 625142448 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0xf83c5fbd Device Boot Start End Blocks Id System /dev/sda1 2048 625141759 312569856 83 Linux /dev/sda1은 파티션에 관한 정보고 여기서 필요한건 /dev/sda이다.</description></item><item><title>원리부터 파악하는 OpneCV</title><link>https://iwanhae.github.io/p/introduction-to-opencv/</link><pubDate>Sat, 03 Oct 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/introduction-to-opencv/</guid><description>서론 OpenCV에 대해 포스팅되는 글들에대해 개인적으로 분류를 해보자면 크게 두가지 부류가 있다. 하나는 &amp;ldquo;나도 이게 어떻게 되는지는 모르지만 일단 되는류&amp;rdquo; 고 나머지 하나는 &amp;ldquo;난 이미 너무 자세히 알고있어서 기초에대해 포스팅할 마음이 안생기는류&amp;ldquo;이다.
이것이 진실로 그러하든 그러하지않던 초보자에게 한글로된 문서만 보고 OpenCV입문이란 힘든다는것은 아마 대부분의 사람들이 공감할것이라 믿는다.
그래서 비교적 최신버전(3.0)에 기초하여 OpenCV가 사용하는 기본적인 함수부터 개발자가 이러한 함수를 만든 의도까지 살려서 C++ 혹은 객체지향언어의 본질을 깨달은 사람을 대상으로 &amp;ldquo;이정도 이해했으면 나머지는 알아서 할수있겠지!</description></item><item><title>공기저항을 고려한 자유낙하</title><link>https://iwanhae.github.io/p/free-fall-with-air-resistance/</link><pubDate>Tue, 22 Sep 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/free-fall-with-air-resistance/</guid><description>k는 현재의 공기저항 상수 s는 거리 v는 속도 a는 가속도 F는 힘 g는 중력가속도 공기저항은 속도 제곱에 비례하다는 가정하에 다음과 같은 결과가 나온다.
$$F\quad =\quad ma\quad =\quad mg-k{ v }_{ }^{ 2 }$$
$$a\quad =\quad \frac { mg\quad -\quad k{ v }^{ 2 } }{ m } \quad =\quad g-\frac { k{ v }^{ 2 } }{ m } \quad =\frac { dv }{ dt } $$
$$dv\quad =\quad (g-\frac { kv }{ m } )dt$$</description></item><item><title>엔트로피 인코딩 (엔트로피 부호화)</title><link>https://iwanhae.github.io/p/entropy_encoding/</link><pubDate>Mon, 21 Sep 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/entropy_encoding/</guid><description>무손실 압축같은 분야에서 애용되는 기법으로
여기서 엔트로피(entropy)는
&amp;lt;통신&amp;gt; 정보량의 기대치를 이르는 말. [비슷한 말] 평균 정보량. 이라는 의미로 사용된다.
말그대로 기대되는 정보량에대해 부호화(encoding)을 한다는것이다.
예를들면
10001010110101001111010100000 같은걸
1(0, 3개)(10,2개)1(10,2개).....(0,5개) 와 같이 부호화 해준다는 거다.
대표적 엔트로피 인코딩 기법으론 허프만 부호화, 범위 부호화와 산술 부호화, 런 렝스 코딩 등이 있다.</description></item><item><title>우분투 서버 한글화 절차</title><link>https://iwanhae.github.io/p/locale_setting/</link><pubDate>Sun, 20 Sep 2015 00:00:00 +0000</pubDate><guid>https://iwanhae.github.io/p/locale_setting/</guid><description>apt-get install language-pack-ko locale-gen ko_KR.UTF-8 LANG=ko_KR.URF-8 LANGUAGE=ko_KR:ko:en_GB:en 그후 /etc/default/locale 에다가
LANG=ko_KR.UTF-8 추가해준뒤 재부팅
locale 커맨드로 ko_KR.UTF-8가 제대로 설정되었는지 확인.
14.04버전 기준이다. Debian계열에선 전부 작동한다.</description></item></channel></rss>